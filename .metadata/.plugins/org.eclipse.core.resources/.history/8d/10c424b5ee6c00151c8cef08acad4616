import intel.rssdk.*;
import java.lang.System.*;
import java.util.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.image.*;
import java.awt.*;

public class CameraViewer
{    
    static int cWidth  = 640;
    static int cHeight = 480;
    static int dWidth, dHeight;
    static boolean exit = false;
    
    
    public static void main(final String s[])
    {
    	//create Instance
        final PXCMSenseManager senseMgr = PXCMSenseManager.CreateInstance(); 
        pxcmStatus sts = senseMgr.EnableHand(null);
        sts = senseMgr.EnableStream(PXCMCapture.StreamType.STREAM_TYPE_DEPTH);
        sts = senseMgr.Init();
        System.out.println(sts);
        
        final PXCMCapture.Device device = senseMgr.QueryCaptureManager().QueryDevice();
        final PXCMCapture.Device.StreamProfileSet profiles = new PXCMCapture.Device.StreamProfileSet();
        device.QueryStreamProfileSet(profiles);
        dWidth = profiles.depth.imageInfo.width;
        dHeight = profiles.depth.imageInfo.height;
	    	final PXCMHandModule handModule = senseMgr.QueryHand(); 
	        final PXCMHandConfiguration handConfig = handModule.CreateActiveConfiguration(); 
	        handConfig.EnableAllGestures();
	        handConfig.EnableAllAlerts();
	        handConfig.EnableTrackedJoints(true);
	        handConfig.EnableNormalizedJoints(true);
	        handConfig.ApplyChanges();
	        handConfig.Update();
	        System.out.println(sts);
              
                 
	        final Listener listener = new Listener();
	        
	        final CameraViewer c_raw = new CameraViewer(); 
			final DrawFrame c_df = new DrawFrame(cWidth, cHeight);
	        final JFrame cframe= new JFrame("Intel(R) RealSense(TM) SDK - Color Stream");	
	        cframe.addWindowListener(listener);
			cframe.setSize(cWidth, cHeight); 
	        cframe.add(c_df);
	        cframe.setVisible(true);
        
        final CameraViewer d_raw = new CameraViewer(); 
		final DrawFrame d_df=new DrawFrame(dWidth, dHeight);      
        final JFrame dframe= new JFrame("Intel(R) RealSense(TM) SDK - Depth Stream"); 
		dframe.addWindowListener(listener);
		dframe.setSize(dWidth, dHeight); 
        dframe.add(d_df);
        dframe.setVisible(true); 
             
        if (sts.compareTo(pxcmStatus.PXCM_STATUS_NO_ERROR)>=0) {
                     
            final PXCMHandData handData = handModule.CreateOutput();
            if (sts == pxcmStatus.PXCM_STATUS_NO_ERROR)
            {
             	final PXCMCapture.Sample sample = senseMgr.QuerySample();
                
                if (sample.color != null)
                {
	                final PXCMImage.ImageData cData = new PXCMImage.ImageData();                
    	            sts = sample.color.AcquireAccess(PXCMImage.Access.ACCESS_READ,PXCMImage.PixelFormat.PIXEL_FORMAT_RGB32, cData);
        	        if (sts.compareTo(pxcmStatus.PXCM_STATUS_NO_ERROR) < 0)
					{
            	        System.out.println ("Failed to AcquireAccess of color image data");
                	    System.exit(3);
                    }
                 
                    final int cBuff[] = new int[cData.pitches[0]/4 * cHeight];
                    
	                cData.ToIntArray(0, cBuff);
    	            c_df.image.setRGB (0, 0, cWidth, cHeight, cBuff, 0, cData.pitches[0]/4);
        	        c_df.repaint();  
           	        sts = sample.color.ReleaseAccess(cData);
					
              	    if (sts.compareTo(pxcmStatus.PXCM_STATUS_NO_ERROR)<0)
					{
                    	    System.out.println ("Failed to ReleaseAccess of color image data");
                        	System.exit(3);
                    }
				}
			
                if (sample.depth != null)
				{       
                    final PXCMImage.ImageData dData = new PXCMImage.ImageData();
                    sample.depth.AcquireAccess(PXCMImage.Access.ACCESS_READ,PXCMImage.PixelFormat.PIXEL_FORMAT_RGB32, dData);
                    if (sts.compareTo(pxcmStatus.PXCM_STATUS_NO_ERROR)<0)
					{
                        System.out.println ("Failed to AcquireAccess of depth image data");
                        System.exit(3);
                    }

                    final int dBuff[] = new int[dData.pitches[0]/4 * dHeight];
                    dData.ToIntArray(0, dBuff);
                    d_df.image.setRGB (0, 0, dWidth, dHeight, dBuff, 0, dData.pitches[0]/4);
                    d_df.repaint();
                    sts = sample.depth.ReleaseAccess(dData);
                    if (sts.compareTo(pxcmStatus.PXCM_STATUS_NO_ERROR)<0)
                    {
                        System.out.println ("Failed to ReleaseAccess of depth image data");
                        System.exit(3);
                    }
                }  
            }
            for (int nframes=0; nframes<30000; nframes++) {         	
                sts = senseMgr.AcquireFrame(true);
                if (sts.compareTo(pxcmStatus.PXCM_STATUS_NO_ERROR)<0) break;
                final PXCMCapture.Sample sample = senseMgr.QueryHandSample();
                
                // Query and Display Joint of Hand or Palm
                sts = senseMgr.AcquireFrame(true);

                handData.Update(); 
                System.out.println ("Frame # " + nframes + " Hands: " + handData.QueryNumberOfHands());
                final PXCMHandData.IHand hand = new PXCMHandData.IHand(); 
                sts = handData.QueryHandData(PXCMHandData.AccessOrderType.ACCESS_ORDER_NEAR_TO_FAR, 0, hand);
                
                //if (sts.isError())
                    //continue;
                
                final PXCMHandData.JointData data = new PXCMHandData.JointData();                         
                if (sts.compareTo(pxcmStatus.PXCM_STATUS_NO_ERROR) >= 0) {
                    hand.QueryTrackedJoint(PXCMHandData.JointType.JOINT_CENTER, data);
                    final PXCMPointF32 image = hand.QueryMassCenterImage();
                    final PXCMPoint3DF32 world = hand.QueryMassCenterWorld();
                    System.out.println("Palm Center at frame " + nframes + ": ");
                    System.out.print("   Image Position: (" + image.x + "," +image.y + ")");
                    System.out.println("   World Position: (" + world.x + "," + world.y + "," + world.z + ")");
                }
            
                // alerts
                final int nalerts = handData.QueryFiredAlertsNumber();
                System.out.println("# of alerts at frame " + nframes + " is " + nalerts);
            
                // gestures
                final int ngestures = handData.QueryFiredGesturesNumber();
                System.out.println("# of gestures at frame " + nframes + " is " + ngestures);

                senseMgr.ReleaseFrame();
            }
            System.exit(0);
        }
        else
        {
            System.out.println("Failed to initialize");
        }
        
        cframe.dispose();
        dframe.dispose();
    }
  
}

class Listener extends WindowAdapter {
    public boolean exit = false;
	@Override public void windowClosing(final WindowEvent e) {
		exit=true;
	}
}



class DrawFrame extends Component { 
    public BufferedImage image; 

    public DrawFrame(final int width, final int height) { 
       image=new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);
    } 
  
    public void paint(final Graphics g) { 
        ((Graphics2D)g).drawImage(image,0,0,null); 
    }
}